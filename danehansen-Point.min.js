(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("@danehansen/math"));
	else if(typeof define === 'function' && define.amd)
		define(["@danehansen/math"], factory);
	else if(typeof exports === 'object')
		exports["point"] = factory(require("@danehansen/math"));
	else
		root["danehansen"] = root["danehansen"] || {}, root["danehansen"]["point"] = factory(root["danehansen"]["math"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_0__;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.angle = angle;
exports.distance = distance;
exports.interpolate = interpolate;
exports.intersection = intersection;
exports.length = length;
exports.normalize = normalize;
exports.polar = polar;
exports.randomPointInCircle = randomPointInCircle;
exports.rotate = rotate;
exports.round = round;
exports.toString = toString;

var _math = __webpack_require__(0);

function add(a, b) {
  return { x: a.x + b.x, y: a.y + b.y };
}

function angle(point) {
  return Math.atan2(point.y, point.x);
}

function distance(a, b) {
  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
}

function interpolate(start, end, amount) {
  return { x: start.x + (end.x - start.x) * amount, y: start.y + (end.y - start.y) * amount };
}

function intersection(startA, endA, startB, endB) {
  var x1 = startA.x;
  var y1 = startA.y;
  var x2 = endA.x;
  var y2 = endA.y;
  var x3 = startB.x;
  var y3 = startB.y;
  var x4 = endB.x;
  var y4 = endB.y;
  var a = x1 - x2;
  var b = y3 - y4;
  var c = y1 - y2;
  var d = x3 - x4;
  var e = a * b - c * d;
  if (e === 0) {
    return null;
  }
  var f = x1 * y2 - y1 * x2;
  var g = x3 * y4 - y3 * x4;
  return { x: (f * d - a * g) / e, y: (f * b - c * g) / e };
}

function length(point) {
  return distance(point, { x: 0, y: 0 });
}

function normalize(point, thickness) {
  var l = length(point);
  var ratio = thickness / l;
  return { x: point.x * ratio, y: point.y * ratio };
}

function polar(len, angle) {
  return { x: Math.cos(angle) * len, y: Math.sin(angle) * len };
}

function randomPointInCircle(center, radius) {
  var random = {};
  do {
    random.x = Math.random() * radius * 2 + center.x - radius;
    random.y = Math.random() * radius * 2 + center.y - radius;
  } while (distance(random, center) > radius);
  return random;
}

function rotate(point, angle) {
  var center = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { x: 0, y: 0 };

  var sin = Math.sin(angle);
  var cos = Math.cos(angle);
  var x = point.x,
      y = point.y;

  var centerX = center.x;
  var centerY = center.y;
  x -= centerX;
  y -= centerY;
  return { x: x * cos - y * sin + centerX, y: x * sin + y * cos + centerY };
}

function round(point) {
  var increment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

  return { x: (0, _math.round)(point.x, increment), y: (0, _math.round)(point.y, increment) };
}

function toString(point) {
  return '{x: ' + point.x + ', y: ' + point.y + '}';
}

/***/ })
/******/ ]);
});